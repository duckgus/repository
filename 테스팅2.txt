임베디드 시스템

큰 시스템의 일부로 특정 목적을 위해 하드웨어를 제어하는 시스템
특징
다양한 OS와 하드웨어에서 작동
소프트웨어가 개발된 후에도 운영하드웨어가 준비되지 않을 수 있다.
운영환경의 자원이 테스트를 수행하기에 부족한 경우도 있다.

사용자가 메뉴 버튼을 누름으로써 시스템을 동작하게 하는 것 = user-driven방식

센서 감지 등을 통해 인터럽트를 발생시켜 시스템이 제어하도록 하는 것 = Enven-Driven

● Event – driven : User-driven 기능과 event-deiven 기능이 혼재됨
● Time Critical : 때때로 시간 제약 사항이 있는 경우가 존재함
● Platform Diversity : 플랫폼(H/W, OS 등)이 매우 다양함
● Hardware : SW개발과 HW가발 병행으로 인하여 HW공급이 늦음
● Gap Between Host Env. And Target Env. : 개발환경과 실제 운영환경이 다름
● Monitoring Media : 모니터링을 위한 별도의 장비가 없는 경우가 많음
● Memory : 메모리 제약이 극심함


테스팅이란
결함 발견, 결함 예방, 품질 수준에 대한 신뢰성 확보
의사결정 정보 제공

결함 발견 -> 테스팅
결함 해결 -> 디버깅

SW에서의 결함
sw가 명세서에 명시된 동작을 하지않거나 명시되지않은 동작을 실행
sw가 명세서에 언급하지 않은 동작을 실행
sw가 명세서에 언급하지 않았지만 해야하는 걸 안하는 경우
sw가 사용하기 불편하고 사용자에게 불편함

배포 전 결함 : 배포 전 결함이 발견이 된다면 수정과 업그레이드가 용이하다
배포 후 결함 : 제품의 신뢰도가 하락 및 사람이 다치는 등의 경우 발생

소프트웨어 테스팅의 분류
테스트 방법 정적(워크쓰루, 인스펙션), 동적(블랙박스, 화이트박스)
블랙박스테스트
- 명세 정보를 이용하여 테스트 케이스를 설계
화이트박스 테스트
- 프로그램 코드 정보를 이용하여 테스트 케이스 설계

다중 V-모델
Verification은 고차원적이고 근복적이고 validation 이후에 진행되는 과정속에서 제대로 만들어졌는지를 검증

임베디드 소프트웨어 테스트의 고려사항
- 이벤트에 따른 상태 변화를 고려하여 테스트
- 시작 제약 조건을 고려한 테스트
- 다양한 플랫폼을 대상으로 효과적으로 테스트
- 운영환경에 크게 의존되지 않는 테스트
- 자원 부족 및 메모리 제약을 고려하여 작은 단위로 테스트

SW 테스팅 프로세스
1. 테스트 계획과 제어
2. 테스트 분석과 설계
3. 테스트 실제 구현
4. 테스트를 종료할 전제 조건을 비교판단하여 결과를 리포팅
5. 테스트 종료 활동

SW테스트 레벨
- 구성요서 테스트(컴포넌트 테스팅)
- 통합 테스트(integration 테스팅)
- 시스템 테스트(System testing)
- 합격 시험(Acceptance testing)

테스팅의 목적에 따른 분류
- Functional Testing : 활용 가능한 SW모델
- Non Functional Testing : 다양한 척도 또는 스케일로 ' 정량화 가능한 SW 품질 특성' 측정
- Structural Testing : 특정 구조 커버리지를 평가하여 테스팅의 충분함을 측정
- Retesting/Regression Testing : 결함을 수정하는 과정에서 야기됐거나 발견되지 않았던 또 다른 결함 발견이 목적

동등성 분할
- Input/ Output Space를 유한개의 상호 독립적인 집합들로 구분하여 각 집합의 대표 테스트케이스를 도출
경계값 분석
테스트 대상의 input 또는 output space의 경계 값에 초점을 맞추어 테스트 케이스를 도출

테스팅의 오해 
테스트는 완벽하게 수행될 수 있다.
시간, 인력이 부족해서 테스팅을 제대로 못한다.
테스트는 어려운 작업이 아니다. 아무나 할 수 있다.
시스템이 잘 동작함을 보여주는 것이다.
테스트는 개발 이후의 작업이다.
개발일정에 따라 테스트는 생략될 수 있다.

테스트 기본 원리
1. 프로그램을 완전하게 테스트하는 것은 불가능하다
2. 테스트는 오류가 없음을 보여주지 않는다.
3. 적은 수의 모듈에서 대부분의 결함이 발견되거나 이로 인해 운영상 장애를 일으킨다. (버그 팔로우 버그)
4. 살충제 패러독스
5. 가능한 빨리 테스트를 시작하는 것이 좋다

원리
완전한 테스트는 불가능하다
테스트의 한계 -> 종료조건 제시
결합 집중 원칙 (버그 팔로우 버그)

파레토의 원리 (오류가 20 수정비용이 80)
살충제 패러독스 : 동일한 케이스를 반복시 놓치는 경우가 있기때문에 새로운 테스트를 개발해야 함
빠른 테스트 : 테스트는 개발초기부터 시작하라

Debugging-oriented : 테스트와 디버깅의 차이가 뚜렷하지않다
Demonstration-oriented : 정상 동작을 보여주기 위한 테스트
Destruction-oriented : 오류가 존재함을 보여주기 위한 테스트
Evaluation-oriented : 개발 전체 단계에서 오류를 발견하는 것
Prevention-oriented : 오류가 발생하지 않도록 사전에 방지하는 것

개발 프로세스
폭포수 모델, 개발 중심의 모델, 코딩 후 테스트가 수행

V-모델
개발과 테스트를 동등하게 취급
개발이 시작됨과 동시에 테스를 계획 및 설계를 위한 활동이 시작

임베디드 시스템 개발 프로세스
1. 시스템 명세 작성
2. 시스템을 소프트웨어 부분과 하드웨어 부분으로 분할
3. 독립적인 하드웨어 설계부분과 소프트웨어 설계 부분 개발 및 테스트
4. 소프트웨어 설계부분과 하드웨어 설계부분 통합 및 통합 테스트
5. 1~4를 반복하여 릴리스 조건 충족시 출시

테스트 프로세스의 일반적인 절차
 테스트( 계획 및 제어 -> 분석 및 설계 -> 케이스 구현 -> 실행 및 리포팅 -> 마감활동)

테스트 정책
- 조직 레벨 최상위 테스트 문서
- 테스트 수행 목적 중심 일반적 내용
테스트 전략 
- 조직 레벨 테스트 문서
- 테스트 방법 중심으로 상세한 내용 
- 테스트 계획에 반영
테스트 계획
- 언제, 누가, 어떻게 리스크를 분석
- 마스터 테스트 계획
- 단계별 테스트 계획 
- 테스트 종료 기준 

IEEE 829 테스트 문서
테스트(계획서, 설계 명세서, 케이스 명세서, 절차 명세서, 인시던트 보고서, 로그, 항목 전달 보고서, 요약 보고서)
설계 명세서
- 테스트 계획서에 테스트 케이스를 설계하고 접근 방식을 상세화 / 대상에 대한 성공,실패의 기준을 기술
케이스 명세서
- 입력으로 사용된 실제 값과 그에 따른 예상 결과 값을 문서화 / 테스트 상의 제약 사항을 문서화
케이스 절차 명세서
- 테스트 케이스를 수행하기 위한 모든 단계를 정의

테스팅은 품질 향상과 보증을 위한 가장 중요한 수단
테스팅으로만 결함을 유일하게 확인할 수 있다.

테스팅 설계 : 테스팅에 최적화된 입력값을 찾는 작업

의도한 실행을 테스트하기 위해 필요한 사항
명세서가 반드시 존재 -> 의도한대로 되었는지 확인이 필요
명세서 내에서 코드로 대응되는 부분을 테스트케이스로 반영

오라클(Oracle)
소프트웨어가 동작하여 도출될 것으로 예상되는 값 / 명세서로부터 다른 방법으로 얻어지는 값
테스트 케이스를 통해 실행된 값을 오라클과 비교하여 명세서의 내용과 일하는지 판단
오라클은 확보가 어렵고 뚜렷한 오라클이 존재하지않는 경우가 있음

테스팅 자동화가 중요한 작업
테스팅 케이스를 통하여 의도한 작업을 수행하는지 확인하는 작업
비슷한 작업이 반복과 진행되는 작업의 정밀성있게 진행되어야 함
테스트 케이스 설계와 오라클 확보는 자동화가 어려운 작업

소프트웨어 품질 요소
기본적으로 명세서의 내용에 부합되는 소프트웨어는 품질이 좋다고 할 수 있음
그러나 꼭 우수한 소프트웨어 라고는 못한다.

MnCall의 소프트웨어의 품질 요소 분류
운영에 적합한지 판단하는 품질요소
변경하기에 편한 정도를 나타내는 품질 요소
다른 목적에 사용하기 편한 요소
요구정도, 기능적인 쇼소의 만족값이 품질을 나타낸다.

품질 요소
정확성, 신뢰성, 성능, 무결성, 사용편의성

변경관련 품질요소
이식성, 재사용가능성, 상호운용성

R.L.Glass의 품질요소
이식성, 신뢰성, 성능, 사용편의성, 시험가능성, 이해도, 수정용이성

FreeMan 품질요소
요구되는 기능, 신뢰성, 사용편의성, 안전성, 적정한 가격, 융통성

결함의 예방
구조적 프로그래밍 : 구조적으로 잘 작성된 프로그램은 이해와 결함의 발견이 빠름
모듈화 설계 기법 : 모듈의 크기를 작게 만들수록 모듈내의 실행 경로수가 현저히 감소

테스팅이 어려운 이유
불완전한 명세의 문제
테스트를 위한 환경 구축의 어려움
소프트웨어 고유 특성에 따른 문제
소프트웨어 테스트 마인드의 부재

소프트웨어 테스팅의 목적
명세서를 기반으로 코드의 검증, 요구사항의 확인

테스팅의 목적에 따른 분류
확인테스트 / 일치테스트, 통합테스트 
테스트 기반에 따른 분류
명세 기반 테스트, 구조 기반 테스트, 결함 기반, 용도 기반
테스트 설계 기법에 따른 분류 
체계적 테스트 무작위 테스트

테스트 수준에 따른 분류
Component Testing : 가능한 많은 단위 내의 결함 제거
inteGration Testing : 가능한 많은 통합적 결함 제거
System Testing : 전체 기능상의 결함제거 및 비기능적 요소 확인
Acceptanc Testing : 요구사항과의 일치성 확인 

테스팅의 한계
각 기법들은 테스팅 시 서로 대체할 수 없는 경우가 많음

블랙박스 : 테스트에 사용할 입력값을 결정한 뒤 프로그램의 실행으로 도출한 출력값을 비교
화이트박스 : 조사 하고자하는 프로그램 실행 경로를 선택하고 경로 실해 가능한 입력값을 준비하고 실행

소프트웨어 테스트의 절차
테스트 설계 -> 실행 -> 결과 및 평가

테스트 계획과 제어
테스트 계획 수립은 테스트의 목적과 임무 달성을 위한 요소들의 면밀한 확인 활동

테스트 분석과 설계
일반적이고 추상적인 테스팅의 목적을 실체화하여 테스트 상황과 테스트케이스로 변환하는 활동

테스트 구현과 실행
효과적적인 테스트를 위해 테스트 케이스를 조합하고
실행에 필요한 다양한 정보를 포함하는 테스트 절차를 면세화 하는 활동

완료 조건 평가와 보고
초기에 정의된 테스트 목표에 비해 실제 테스트가 수행된 정도를 평가하는 활동

테스트 마감 활동
완료된 테스트 활동에서 데이터를 수입하여 발견된 사실, 수치적 데이터와 테스팅 경험을 종합하고 축적하느 활동

테스트 케이스의 설계
개발하는 sw를 테스트 하기 위해 필요한 테스트 케이스를 도출하는 작업

케이스 상호간의 중복성x
케이스가 작을수록 좋지만 발견확률이 낮음

테스트케이스 설계과정
테스팅 대상 프로그램의 결함에 관한 단서 수집
단서를 구체적인 테스트 요구사항으로 정의
각 테스트 항목에 대한 테스트 명세 작성 

오라클의 분류
명세서 기반 -> 쉽게 구할 수 있음
코드 기반 -> 다른 수단으로 확보, 코드의 예측값 확보

테스트 기준
테스팅의 충분여부를 판단하는 기준
테스트 충분조건, 테스트 데이터 선정 기준, 커버리지 기준, 테스트 종결 기준
충분조건이 갖추어야할 성질
단조성, 비확장성, 일반적인 다중 변화, 비분해성, 비합성성, 상속

테스트 프로세스의 자동화 
테스트 작업 자동화, 도구의 사용으로 인한 이점
- 효율적으로 수행가능, 병행하여 다른 작업의 수행가능, 실수를 최소화
자동화가 어려운 테스트 작업
추가 수행 및 완료 등의 판단
결과의 수집 및 분석

정적 분석 : 프로그램의 실행 없이 소프트웨어의 결함을 검출하는 작업
정적분석과 테스팅은 모두 결함을 검출하려는 목적은 같으나 다른 유형의 결함을 검출함(상호보완적)
체크리스트 : 개발 산출물에 대한 검토(비정형적 검토)
워크스루 : 개발 산출물에 대해 작성 관련자의 절차에 따른 검토(정형적 검토)

검토기법
검토는 실행 없이 개발과정의 중간 산출물을 점검하여 결함을 발견하는 작업
참여인원수, 절차의 경중에 따라 구분함

비정형적 테스팅 기법
- 인간기반 테스팅 기법. 에러를 찾는데 효과적, 컴퓨터 기반 테스팅 전에 적용되어야함
- 더 빨리 에러를 발견, 수정 비용감소, 정확성 향상

인스펙션
일련의 절차에 따라 참여자가 함께 테스트 베이시스 읽기를 통해 결함을 탐색
팀구성 : 4명 내외, 중재자(개발자x), 프로그래머, sw설계자, 테스터 등
중재자의 임무
회의 자료 배포 및 일정관리
회의 주관, 발견한 결함기록, 수정된 결함 확인
참석자에게 회의전 리스트 및 명세서 배포

소프트웨어 에러의 유형
정적분석을 통한 결함의 검출 시 에러 유형에 대한 사전 지식을 활용하여 분석하면 효과적인 결함 검출이 가능
데이터 참조 에러
데이터 선언 에러
연산 에러
비교 에러
제어 흐름 에러
인터페이스 에러
입출력 에러
단순 실수

데이터 참조 에러(체크리스트)
설정 안 된 변수 사용
경계 내 첨자
정수가 아닌 첨자
허상 참조
별명 사용시 올바른 속성
레코드와 구조 속성 일치
비트 문자열 주소 연산
올바른 기본 저장 속성
상속 요구 일치

데이터 선언 에러(체크리스트)
모든 변수 선언
알고 있는 기본 속성
배열과 문자열의 적절한 초기화
올바른 길이, 타입, 저장 클래스 지정
저장 클래스와 일치하는 초기화 
비슷한 이름의 변수

연산에러(체크리스트)
산술 할 수 없는 변수의 연산
혼합모드 연산
길이가 다른 변수의 연산
할당 값보다 작은 변수 크기
중간 값이 오버플로우나 언더플로우
0으로 나눔
부정확한 이진수
올바른 정수 연산?

비교 에러 (체크리스트)
1. 일치하지 않는 변수 비교?
2. 혼합모드 비교?
3. 올바른 비교 관계?
4. 올바른 Bool 표현?
5. Bool 표현과 비효 혼합?
6. 2진수 분수 값의 비교?
7. 알고 있는 연산자 순서?
8. Bool 표현의 컴파일러 평가?

 제어흐름 에러(체크 리스트)
1. 다중 분기?
2. 각 루프는 종료되었는가?
3. 프로그램은 종료되었는가?
4. 시작 조건 때문에 루프를 지나치는가?
5. 지나가는 루프는 올바른가?
6. 한 번씩 벗어나는 반복 에러?
7. Do/End 문장 수의 일치?
8. 누학된 결정?
9. 출력 정보의 철자나 문법적 에러?

 인터페이스 에러(체크 리스트)
1. 입력 파라미터 수와 인수의 수 일치?
2. 파라미터와 인수 속성의 일치?
3. 파라미터와 인수 단위의 일치?
4. 호출된 모듈에 전송되는 인수 수와 파라미터 수의 일치?
5. 호출된 모듈에 전송되는 인수의 속성과 파라미터 속성의 일치?
6. 호출된 모듈에 전송되는 인수의 단위와 파라미터 단위의 일치?
7. 내장된 함수 인수의 올바른 수, 속성, 순서
8. 현재 시작 포인트와 관련 없는 파라미터 참조?
9. 입력 전용 인수의 변경
10. 모든 모듈에서 전역 변수 정의 일치?
11. 인수로 상수 전달?

 입출력 에러(I/O 에러(체크 리스트))
1. 올바른 파일 속성?
2. 올바른 Open 문장?
3. 포맷 명세는 I/O문장과 일치?
4. 버퍼 크기는 레코드 크기와 일치?
5. 사용 전 파일 열기?
6. 사용 후 파일 닫기?
7. End-of-filw 조건 처리?
8. I/O에러에 대한 적절한 처리?

 기타(단순 에러)
1. 상호 참조 리스트에서 참조되지 않는 변수?
2. 예상되는 속성 리스트?
3. 경고나 정보 메시지?
4. 유효성을 위한 입력 확인?
5. 누락된 기능?

비공식 검토
개별 검토
- 가장 간단하면서 기초적인 검토 형태
- 자신이 작업 산출물을 점검
- 한사람이 하는 인스펙션 또는 워크 쓰루
- 다른 공식검토에 비해 비생산적

동료 검토 
- 산출물 다른 동료가 검토하는 비교적 간단한 검토 형태
- 익명의 프로그램에 대해 개인적인 평가

워크스루
- 미리 정의된 역할을 수행할 다수의 검토요원이 정해진 절차와 준비과정을 거쳐 시행하는 검토 기법
- 객관성 확보 가능
- 페이건 사열
절차상의 차이와 결함 검출 방법이 다름(규모가 큼)

공식검토
 공식적인 관리팀에 의해 프로젝트 진도, 프로세스, 품질을 평가하는 활동
소프트웨어 요구 사항 검토 (SRR)
예비 설계 검토
상세 설계 검토
테스트 준비상태 검토
소프트웨어 인수 검토

SW테스트 설계 기술
명세기반 기법
- 테스트를 설계할때 코드의 내용과 상관없음
기능 중심으로 테스트 한다.
모델로부터 테스트케이스를 도출
겉으로 드러나는 행위를 조사함 -> 행위적 테스트 

구조기반 기법 화이트 박스 테스트 
코드를 보고 그 코드와 관련된 내용을 검수 한다. 
설계나 구조등의 정보로부터 테스트케이스 검출
커버리지 측정 가능

비공식 기법 (체계화x)
경험기반 체계화를 위해서 문서화 필요

명세기반 테스트 기법
- 주어진 명세를 바탕으로 테스트케이스를 도출 
- 해당 테스트 케이스를 수행하여 중대한 결함이 없음을 보장 가능해야 함 
- 명세서에 대한 면밀한 분석으로 테스트 데이터 수집
입력과 출력값이 필수

동등분할
특정 범위의 입력값에 의해 결과값이 동일한 경우
입력값의 범위를 하나의 그룹으로 간주 -> 그룹별로 대표값 하나를 선택적으로 테스트 데이터 선택 및 테스트 케이스 작성 

경계값 분석 
테스트 대상의 Input or Output 영역의 경계부분에서 결함이 발견될 확률이 높음
분할 영역의 최대값과 최소값을 경계값으로 보고 테스트 데이터 및 테스트 케이스 도출
경계값 분석은 경계값을 명시한 명세서가 지원될 경우 테스트케이스 도출과 테스트가 용이
차이점
동등 클래스의 경계에 있는 값을 테스트 대상이 되는 요소로 선택
입력 조건에만 초점을 맞추기 보다 결과 영역도 고려하여 테스트케이스 도출
​
Single Fault Based Testing
• 테스트 케이스가 경계의 min, min+, normal, max-, max 값으로 산출
• 4n+1 test cases 도출
​
Robustness Testing
• 테스트 케이스가 경계별로 3개의 경우를 고려함 (SFBT에서 max+ 추가)
• 예외사항에 대한 테스트 가능
• 6n+1 test cases
​
Worst Case Testing
• 테스트 케이스가 경계별로 min, min+, normal, max-, max 의 요소가 세트로 구성
• 5^n test cases
경계별로 다 이루어짐, 잘안씀, 효용성이 있을지 보여줄떄 씀
​
Robustness Worst Case Testing
• 테스트 케이스가 경계의 min-, min, min+, normal, max-, max, max+ 의 요소가 세트로 구성
• 7^n test cases
더 좋지만 더 안씀

동등 분할과 경계값 분석 (단위테스트때 많이 사용)
동등 분할과 경계값 분석으 ㅣ 경우 사용하기 용이하면서 활용도가 높은 기법
모든 테스트 단계에서 적용 가능
테스트를 통해 경계값을 통한 결함 발견과 결함의 보장이 쉬움

경계값이나 동시분할에 한계가 있을때 그런 부분을 해결하기 위해서 사용 -> 대표적으로 결정표 테스팅 

결정표 테스팅
논리적인 조건이나 상황을 구현하는 시스템 요구사항을 도출
내부 시스템 디자인을 문서화에 유용
시스템이 구현해야 하는 복잡한 비즈니스 규칙을 문서화하는데 사용
입력 조건과 동작은 참,거짓으로 주로 표현
장점
논리적으로 참,거짓인 경우 쉽게 표현이 가능
테스트 베이시스의 불안성과 모호함을 지적 -> 테스트케이스를 만들면서 결함 발견 가능
단점 
만드는데 많은 시간과 노력이 소요

결정트리, 결정표 작성 요령
원인- 결과 그래프
명세서 상 복잡,모호한 논리 관계를 구조적, 형식적 명세로 변화하는 방법

상태기반 테스트 기법
상태를 가지는 프로그램을 대상으로 하는 시험 기법
입력 값과 상태를 고려하여 시험데이터 생성
상태 기계와 같은 상태전이 다이어그램으로 주로표현
상태전이 테스팅이 대표적인 기법 

상태전이 테스팅
소프트웨어 또는 시스템의 상태 사이의 관계 즉 상태의 변화로 유발되는 동작을 파악

상태전이 테스팅을 통해 가능한 테스트 설계
순서를 커버하는 방식
모든 상태를 커버하는 방식
모든 상태 전이를  실행하는 방식
특정한 상태 전이 순서를 실행하는 방식
불가능한 상태 전이를 테스트 하는 방식

모델상의 결함 
초기 상태 누락
- 전이 또는 액션의 누락
- 가드를 '전이' 대신 상태에 표기
- 가드의 중복or불일치
가드 -> 전이가 발생하는 조건

구현상의 결함(만들어가는 과정에서 결함)
- 여분/누락/훼손 상태
- 액션이나 틀리거나 누락
- 스니크 패스, 트랩 도어
스니크 패스 -> 의도하지 않은 패스가 만들어짐
트랩 도어 -> 과정을 건너뛰고 가는 것
​
상태 전이 테스팅의 설계 절차
- 상태-이벤트 테이블 구성
- 전이 트리 구성
- 반응 테스트 케이스 구성
- 무반응 또는 비유효 "
- 가드 또는 조건 "
- 테스트 프로시저 구성

유즈케이스 테스팅
유즈케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화 하는 방법
​
주류 시나리오 또는 기본 흐름과 대체흐름으로 구성



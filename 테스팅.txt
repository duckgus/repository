임베디드 시스템
큰 시스템의 일부로 특정 목적을 위해 하드웨어를 제어하는 시스템
특징
다양한 OS와 하드웨어에서 작동
소프트웨어가 개발된 후에도 운영 하드웨어가 준비되지 않을 수 있다.]
운영환경의 자원이 테스트를 수행하기에 부족한 경우가 많다.

사용자가 메뉴 버튼을 누름으로써 시스템을 동작하도록 하는 것
=>user-driven 방식

센서 감지 들을 통해 인터럽트를 발생시켜 시스템이 제어하도록 하는 것.
=>Event-Driven

테스팅이란
결함 발견, 결함 예방, 품질 수준에 대한 신뢰성 확보
의사결정 정보 제공

결함 발견 -> 테스팅, 결함 해결 -> 디버깅

SW에서의 결함(SW Defects)
sw가 명세서에 명시된 동작을 하거나 명시되지않은 동작을 실행
sw가 명세서에 언급하지 않은 동작을 실행
sw가 명세서에 언급하지않았지만 해야하는 걸 안함
sw가 사용하기 불편하고 사용자에게 불편함

배포 전 결함 : 배포 전 결함이 발견이 된다면 수정과 업그레이드가 용이할 수 있음
배포 후 결함 : 제품의 신뢰도 하락 및 사람이 다치는 등의 경우 발생

소프트웨어 테스팅의 분류
테스트 방법 - 정적(워크쓰루, 인스펙션등), 동적(블랙박스, 화이트박스)
 블랙박스 테스트
- 명세 정보를 이용하여 테스트 케이스를 설계
 화이트박스 테스트
- 프로그램 코드 정보를 이용하여 테스트 케이스 설계

SW 테스팅 모델

다중 V-Model
Verification은 고차원적이고 근본적이고 Validation 이후에 진행하는 과정속에서 제대로 만들어졌는지를 검증.
 임베디드 소프트웨어 테스트의 고려사항
- 이벤트에 따른 상태 변화를 고려하여 테스트
- 시작 제약 조건을 고려한 테스트
- 다양한 플랫폼을 대상으로 효과적으로 테스트
- 운영황경에 크게 의존되지 않는 테스트
- 자원 부족 및 메모리 제약을 고려하여 작은 단위로 테스트

SW 테스팅 프로세스
1. 테스트 계획과 제어
2. 테스트 분석과 설계
3. 테스트 실제 구현
4. 테스트를 종료할 전제 조건을 비교판단하고 결과를 리포팅
5. 테스트 종료 활동

SW 테스트 레벨
- 구성요소 테스트(Component Testing)
- 통합 테스트(Integration Testing)
- 시스템 테스트(System Testing)
- 합격 시험(Acceptance Testing)

테스팅의 목적에 따른 분류
- Functional Testing : 활용 가능한 SW 모델
- Non Functional Testing : 다양한 척도 또는 스케일로 ‘정량화 가능한 SW 품질 특성’ 측정
- Structural Testing : 특정 구조 커버리지를 평가하여 테스팅의 충분함을 측정
- Retesting/Regression Testing : 결함을 수정하는 과정에서 야기 됐거나 발견되지 않았던 또 다른 결함 발견이 목적       

Specification-based Techniques
- Equivalence Partitioning(동등성 분할): 
Input/Output Space를 유한개의 상호 독립적인 집합(클래스)들로 구분하여 각 집합의 대표 test Case를 도출
- Boundary Value Analysis(경계값 분석) : 
Test 대상의 Input 또는 Output Space의 경계 값에 초점을 맞추어 Test Case를 도출

//2
테스팅의 오해
테스트는 완벽하게 수행될 수 있다.
시간, 인력이 부족해서 테스팅을 제대로 못한다.
테스트는 어려운 작업이 아니다.
아무나 할 수 있다.
시스템이 잘 동작함을 보여주는 것이다.
테스트는 개발 이후의 작업이다.
개발일정에 따라 테스트는 생략 될 수 있다.

테스트 기본 원리
1. 프로그램을 완전하게 테스트하는 것은 불가능
2. 테스트는 오류가 없음을 보여주지 않는다.
3. 적은 수의 모듈에서 대부분의 결함이 발견되거나 이로 인해 운영상 장애를 일으킨다.
4. 살충제 패러독스
5. 가능한 빨리 테스트를 시작하는 것이 좋다.

원리
완전한 테스트는 불가능하다.
테스트의 한계 -> 종료 조건 제시
결함 집중 원칙 -> 위 3번(bugs follow bugs)

파레토의 원리(20%/80%)
오류의 20%가 오류 수정 비용 80%를 차지

살충제 패러독스 -> 동일한 케이스를 반복시 놓치는 경우가 있음 새로운 테스트를 개발해야 함

빠른 테스트 -> 개발 초기부터 시작하라


Debugging-oriented 테스트와 디버깅의 차이가 뚜렷하지 않음
Demonstration-oriented 정상 동작을 보여주기 위한 테스트
Destruction-oriented 오류가 존재함을 보여주기 위한 테스트
Evaluation-oriented 개발 전체 단계에서 오류 발견
Prevention-oriented 오류가 발생하지 않도록 사전에 방지

개발 프로세스
폭포수 모델
개발 중심의 모델
코딩 후 테스트가 수행

V-모델
개발과테스트를 동등하게 취급
개발이 시작됨과 동시에 테스트 계획 및 설계를 위한 활동이 시작

임베디드 시스템 개발 프로세스
1. 시스템 명세 작성
2. 시스템을 소프트웨어 부분과 하드웨어 부분으로 분할
3. 독립적인 하드웨어 설계 부분과 소프트웨어 설계 부분 개발 및 테스트
4. 소프트웨어 설계 부분과 하드웨어 설계 부분 통합 및 통합 테스트
5. 1-4를 반복하여 릴리스 조건 충족시 출시

테스트 프로세스의 일반적인 절차는?
테스트 계획 및 제어 -> 
테스트 분석 및 설계 -> 
테스트 케이스 구현(테스트 환경 설계 및 구현) -> 
테스트 실행 및 리포팅 -> 테스트 마감 활동

테스트 프로세스
- 테스트 계획 및 제어
- 테스트 분석 및 설계
- 테스트 케이스 구현
- 테스트 실행 및 리포팅
- 테스트 마감 활동

테스트 정책
- 조직 레벨 최상위 테스트 문서
- 테스트 수행 목적 중심 일반적 내용

테스트 전략
- 조직 레벨 테스트 문서
- 테스트 방법 중심으로 상세한 내용
- 테스트 계획에 반영

테스트 계획
- 언제, 누가, 어떻게, 리스크 분석
- 마스터 테스트 계획 ↓
- 단계별 테스트 계획 ↓
- 테스트 종료 기준

 IEEE 829 테스트 문서
 테스트 계획서(Test Plan)
 테스트 설계 명세서(Test Design Spec)
 테스트 케이스 명세서(Test Case Spec)
 테스트 절차 명세서(Test Prosedere Spec)
 테스트 인시던트 보고서(Test Incident Report)
 테스트 로그(Test Log)
 테스트 항목 전달 보고서(Test Item Teansmittal Report)
 테스트 요약 보고서(TEst Summary Report)

테스트 설계 명세서
테스트 계획서에 테스트 케이스를 설계하고 접근 방식을 상세화
테스트 대상에 대한 성공/실패 기준 기술

테스트 케이스 명세서
테스트를 위해 입력으로 사용된 실제 값과 그에 따른 예상 결과 값을 문서화
테스트 상의 제약 사항을 문서화

테스트 절차 명세서
테스트 케이스를 수행하기 위한 모든 단계를 정의

테스트 인시던트 보고서(중요x)
수행 중에 발생한 문제중에 조사가 요구되는 사건에 대한 문서화

테스트 로그
테스트 수행 중에 발생한 모든 사건을 기록

테스트 항목 전달 보고서
테스트 활동을 위해 전달되는 테스트 항목에 관한 정보를 문서화

테스트 요약 보고서
수행된 테스트 활동을 요약하고 평가

//3
테스팅은 품질 향상과 보증을 위한 가장 중요한 수단
테스팅으로만 결함을 유일하게 확인할 수 있음

테스팅 설계 : 테스팅에 최적화된 입력값을 찾는 작업
-> 입력값을 넣고 제대로된 출력값이 나오는지 확인하는 작업

의도한 실행을 테스트하기 위해 필요한 사항
명세서가 반드시 존재 -> 의도한대로 되었는지 확인이 필요함
명세서 내에서 코드에 대응되는 부분을 테스트 케이스로 반영
-> 테스트 케이스를 가능한 모든 케이스로 만들거나 만들어진 케이스를 테스트하는 것은 거의 불가능함(?)

오라클(Oracle) : 소프트웨어가 동작하여 도출될 것으로 예상되는 값, 명세서로부터 다른 방법으로 얻어지는 값
테스트 케이스를 통해 실행되어 도출된 값을 오라클과 비교하여 명세서의 내용과 일치하는지 판단
오라클은 확보가 어렵고 뚜렷한 오라클이 존재하지 않는 경우가 있음

테스팅은 자동화가 중요한 작업
테스트 케이스를 통하여 의도한 작업을 수행하는지 확인하는 작업
비슷한 작업이 반복과 진행되는 작업의 정밀성있게 진행되어야 함
테스트 케이스 설계와 오라클 확보는 자동화가 어려운 작업

소프트웨어의 품질 요소
기본적으로 명세서의 내용에 부합되는 소프트웨어의 품질이 좋다고 할 수 있음
그러나 꼭 우수한 소프트웨어라고는 못함

McCall의 소프트웨어의 품질 요소 분류
운영에 적합한지 여부를 판단하는 품질 요소
변경하기에 편한 정도를 나타내는 품질 요소
다른 목적에 사용하기 편한 요소
-> 요구정도, 기능적인 요소의 만족도

품질요소
정확성, 신뢰성, 성능, 무결성, 사용편의성

변경하기 쉬운지를 나타내는 품질 요소
유지보수성, 융통성, 시험 가능성

활용도를 높이기 쉬운지를 나타내는 품질 요소
이식성, 재사용가능성, 상호운용성

R.L.Glass의 품질 요소
이식성, 신뢰성, 성능, 사용편의성, 시험가능성, 이해도, 수정용이성 / 줄였음

FreeMan 품질요소
요구되는 기능, 신뢰성, 사용편의성, 안전성, 적정한 가격, 융통성

품질 요소의 결정
안전성
급여 관리 시스템 -> 정확성, 신뢰성, 안정성, 효율성, 유지보수가 쉬어야함 -> 편의성 ↓
DVD 대여관리 : 성능, 신뢰성, 안전성 ↓ / 편의성,저렴 ↑

결함의 예방
구조적 프로그래밍 : 구조적으로 잘 작성된 프로그램은 이해와 결함의 발견이 빠름
모듈화 설계 기법 : 모듈의 크기를 작게 만들수록 모듈내의 실행 경로수가 현저히 감소

테스팅이 어려운 이유
불완전한 명세의 문제
테스트를 위한 환경 구축의 어려움
소프트웨어 고유의 특성에 따른 문제
소프트웨어 테스트 마인드의 부재

소프트웨어 테스팅의 목적
명세서를 기반으로 코드의 검증
요구사항의 확인

에러의 결함, 고장

소프트웨어 테스팅의 유형
정적분석 : 코드만 보고 하는 것
동적분석 : 실행시켜서 확인 하는 것

테스팅의 분류 기준에 따른 종류
목적이 무엇인가, 설계의 기반이 뭔지, 사용한 기법이 뭔지, 어느정도 수준인지

테스팅의 목적에 따른 분류
확인 테스트/일치테스트, 통합테스트

테스트 기반에 따른 분류
명세 기반 테스트, 구조 기반 테스트
결함 기반, 용도 기반

테스트 설계 기법에 따른 분류
체계적 테스트 무작위 테스트

테스트 수준에 따른 분류
Component Testing : 가능한 많은 단위 내의 결함 제거
Integration Testing : 가능한 많은 통합적 결함 제거
System Testing  : 전체 기능상의 결함제거 및 비기능적 요소 확인
Acceptance Testing : 요구사항과의 일치성 확인

테스팅의 한계
각 기법들은 테스팅 시 서로 대체할 수 없는 경우가 많음


//4
블랙박스 : 테스트에 사용할 입력값을 결정한 후 프로그램의 실행으로 도출한 출력값을 비교
화이트박스 : 조사 하고자하는 프로그램 실행 경로를 선택하고 경로 실행이 가능한 입력값을 준비하고 실행

소프트웨어 테스트의 절차
테스트 설계 -> 실행 -> 결과 및 평가

테스트 계획과 제어
테스트 계획 수립은 테스트의 목적과 임무달성을 위한 요소들의 면밀한 확인 활동
주요 작업
- 테스트 범위와 리스크 결정
- 정책의 실현과 전략 구현, 접근 방법에 대한 결정, 리소스의 결정, 일정관리, 완료 조건의 결정

테스트 분석과 설계
일반적이고 추상적인 테스팅의 목적을 실체화하여 테스트 상황과 테스트 케이스로 변환하는 활동
테스트 분석과 설계의 주요 요소
- 테스트 기본 검토
- 테스트 대상의 명세, 동작과 구조의 분석을 통한 테스트 상황 식별 및 우선 순위 선정
- 테스트 케이스 설계와 우선순위 선정
- 비공식적인 테스트 기법으로 테스트 케이스 추가 도출 및 보안
- 테스트 상황과 테스트 케이스에 필요한 테스트 데이터 식별
- 테스트 환경 구축에 대한 설계

테스트 구현과 실행
효과적으로 테스트를 실행하기 위해 테스트 케이스의 조합하고 테스트 실행에 필요한 다양한 정보를 포함하는 테스트 절차를 면세화하는 활동
테스트 케이스의 개발과 구현 및 우선순위 선정
테스트의 자동화
하네스 준비, 절차수행, 오라클 비교 등


완료 조건 평가와 보고
완료 조건 평가는 초기에 정의된 테스트 목표에 비해 실제 테스트가 수행된 정도를 평가하는 활동
테스트 보고는 테스팅 동안 수집한 결함 및 테스트 진행 관련 데이터의 메트릭을 보고하기 위해 변경하는 활동

테스트 마감 활동
완료된 테스트 활동에서 데이터를 수입하여 발견된 사실 및 수치적 데이터와 테스팅 경험을 종합하고 축적하는 활동


테스트 케이스의 설계
개발하는 SW를 테스트 하기 위해 필요한 테스트 케이스를 도출하는 작업(테스트 설계)

케이스 상호간의 중복성 x
케이스가 작을수록 좋지만 발견확률 ↓
SW 테스팅 딜레마 

테스트 케이스의 설계과정
테스팅 대상 프로그램의 결함에 관한 단서 수집
단서를 구체적인 테스트 요구사항으로 정의
각 테스트 항목에 대한 테스트 명세 작성

오라클의 분류
명세기서 기반 -> 쉽게 구함
코드 기반 -> 다른 수단으로 확보, 코드의 예측값 확보

테스트 기준
테스팅의 충분여부를 판단하는 기준
테스트 충분조건, 테스트 데이터 선정 기준, 커버리지 기준, 테스트 종결 기준
충분조건이 갖추어야할 성질
단조성, 비확장성, 일반적인 다중 변화, 비분해성, 비합성성, 상속

테스트 프로세스의 자동화
- 테스트 작업 자동화 도구의 사용으로 인한 이점
효율적으로 수행가능, 병행하여 다른작업의 수행가능, 실수를 최소화
- 자동화가 어려운 테스트 작업
추가 수행 및 완료 등의 판단
결과으 ㅣ수집 및 분석

//5

정적 분석 : 프로그램의 실행 없이 소프트웨어의 결함을 검출하는 작업
정적분석과 테스팅은 모두 결함을 검출하려는 목적은 같으나 다른 유형의 결함을 검출함(상호보완적)
체크리스트 : 개발 산출물에 대한 검토(비정형적 검토)
워크스루 : 개발 산출물에 대해 작성 관련자의 절차에 따른 검토(정형적 검토)

검토기법
검토는 실행 없이 개발 과정으 ㅣ중간 산출물을 점검하여 결함을 발견하는 자겅ㅂ
참여인원수, 절차의 경중 등에따라 구분함

비정형적 테스팅 기법
- 인간기반 테스팅 기법, 에러를 찾는데 효과적, 컴퓨터 기반 테스팅 전에 적용되어야함
- 더 빨리 에러를 발견, 수정 비용감소, 정확성 향상

인스펙션
일련의 절차에 따라 참여자가 함께 테스트 베이시스 읽기를 통해 결함을 탐색
팀 구성 : 4명 내외, 중재자(개발자x), 프로그래머, sw설계자, 테스터등
중재자의 의무
회의 자료 배포 및 일정관리
회의 주관, 발견한 결함기록, 수정된 결함 확인
참석자에게 회의전 리스트 및 명세서 배포

소프트웨어 에러의 유형
정적분석을 통한 결함의 검출 시 에러 유형에 대한 사전 지식을 활용하여 분석하면 효과적인 결함 검출이 가능
데이터 참조 에러, 데이터 선언 에러, 연산 에러, 비교 에러
제어 흐름 에러, 인터페이스 에러, 입출력 에러, 단순 실수

데이터 참조 에러(체크리스트)
설정 안 된 변수 사용
경계 내 첨자
정수가 아닌 첨자
허상 참조
별명 사용시 올바른 속성
레코드와 구조 속성 일치
비트 문자열 주소 연산
올바른 기본 저장 속성
상속 요구 일치

데이터 선언 에러(체크리스트)
모든 변수 선언
알고 있는 기본 속성
배열과 문자열의 적절한 초기화
올바른 길이, 타입, 저장 클래스 지정
저장 클래스와 일치하는 초기화 
비슷한 이름의 변수

연산에러(체크리스트)
산술 할 수 없는 변수의 연산
혼합모드 연산
길이가 다른 변수의 연산
할당 값보다 작은 변수 크기
중간 값이 오버플로우나 언더플로우
0으로 나눔
부정확한 이진수
올바른 정수 연산?

비교 에러 (체크리스트)
1. 일치하지 않는 변수 비교?
2. 혼합모드 비교?
3. 올바른 비교 관계?
4. 올바른 Bool 표현?
5. Bool 표현과 비효 혼합?
6. 2진수 분수 값의 비교?
7. 알고 있는 연산자 순서?
8. Bool 표현의 컴파일러 평가?

 제어흐름 에러(체크 리스트)
1. 다중 분기?
2. 각 루프는 종료되었는가?
3. 프로그램은 종료되었는가?
4. 시작 조건 때문에 루프를 지나치는가?
5. 지나가는 루프는 올바른가?
6. 한 번씩 벗어나는 반복 에러?
7. Do/End 문장 수의 일치?
8. 누학된 결정?
9. 출력 정보의 철자나 문법적 에러?

 인터페이스 에러(체크 리스트)
1. 입력 파라미터 수와 인수의 수 일치?
2. 파라미터와 인수 속성의 일치?
3. 파라미터와 인수 단위의 일치?
4. 호출된 모듈에 전송되는 인수 수와 파라미터 수의 일치?
5. 호출된 모듈에 전송되는 인수의 속성과 파라미터 속성의 일치?
6. 호출된 모듈에 전송되는 인수의 단위와 파라미터 단위의 일치?
7. 내장된 함수 인수의 올바른 수, 속성, 순서
8. 현재 시작 포인트와 관련 없는 파라미터 참조?
9. 입력 전용 인수의 변경
10. 모든 모듈에서 전역 변수 정의 일치?
11. 인수로 상수 전달?

 입출력 에러(I/O 에러(체크 리스트))
1. 올바른 파일 속성?
2. 올바른 Open 문장?
3. 포맷 명세는 I/O문장과 일치?
4. 버퍼 크기는 레코드 크기와 일치?
5. 사용 전 파일 열기?
6. 사용 후 파일 닫기?
7. End-of-filw 조건 처리?
8. I/O에러에 대한 적절한 처리?

 기타(단순 에러)
1. 상호 참조 리스트에서 참조되지 않는 변수?
2. 예상되는 속성 리스트?
3. 경고나 정보 메시지?
4. 유효성을 위한 입력 확인?
5. 누락된 기능?

비공식 검토
개별 검토
- 가장 간단하면서 기초적인 검토 형태
- 자신이 작업 산출물을 점검
동료 검토
- 산출물 다른 동료가 검토하는 비교적 절차가 간단한 검토 형태

개별 검토
- 한사람이 하는 인스펙션 또는 워크 쓰루
- 다른 공식검토에 비해 비생산적

동료검토
- 익명의 프로그램에 대해 개인적인 평가

비공식 검토
워크스투
- 미리 정의된 역할을 수행할 다수의 검토요원이 정해진 절차와 준비과정을 거쳐 시행하는 검토 기법
- 객관성 확보가 가능
- 페이건 사열(팀을 구성, 요구수준이 높은 시스템에 활용)
절차상의 차이와 결함 검출 방법이 다름(규모가 큼)

공식검토
공식적인 관리팀에 의해 프로젝트 진도, 프로세스, 품질을 평가하는 활동
소프트웨어 요구 사항 검토(SRR)
예비 설계 검토
상세 설계 검토 
테스트 준비상태 검토
소프트웨어 인수 검토

//6
SW테스트 설계 기술
Specification-based Technique
SW 기능 중심의 테스팅, 공식적/비공식적 모델(명세)사용
모델로부터 테스트 케이스를 체계적으로 도출
코드의 내용은 고려하지 않음(블랙박스테스트)
 Structure-based Technique
- SW 코드나 설계 등 구조를 보여주는 정보로부터 Test Case 도출하여 Coverage 측정 가능
- Coverage를 높이기 위해 Test Case를 체계적으로 추가 가능
 Experience-based Technique
- Tester, Developer, Use 등의 발생 가능한 결함과 그 분포에 대한 경험과 지식 활용
- 문서화 필요

명세기반 테스트 기법
주어진 명세를 바탕으로 테스트 케이스를 도출 하는 것
적은 수의 입력값 선정으로 최대의 테스트 효과를 획득하고자하는 다양한 기법 존재

동등분할
특정 범위의 입력값에 의해 결과값이 동일한 경우 입력값의 범위를 하나의 그룹으로 간주하여 그룹별로 대표값 하나를 선택적으로 테스트 데이터 선택 및 테스트 케이스 작성
필요시 모든 테스트 레벨에서 사용 가능

경계 값 분석
테스트 대상의 Input 또는 Output 영역의 경계부분에서 결함이 발견될 확률이 높음
분할 영역의 최대값과 최소값을 경계값으로 보고 테스트 데이터 및 케이스 도출

차이점
동등 클래스의 경계에 있는 값을 테스트 대상이 되는 요소로 선택
입력 조건에만 초점을 맞추기 보다 결과 영역도 고려하여 테스트케이스 도출

//7
결정표 테스팅
논리적인 조건이나 상황을 구현하는 시스템 요구사항을 도출하거나 내부 시스템 디자인을 문서화하는데 유용
장점
논리적으로 의존적인 모든 조건들의 조합을 생성함
유고사항 등 테스트 베이시스의 문제점을 드러나게하는 효과적인 테스트 케이스 생성가능
단점
작성에 많은 노력과 시간이 소요될 수 있음
복잡한 시스템을 표현하기 어려울 수 있고, 논리적 실수의 소지가 있음

상태 기반 테스트 기법
상태를 가지는 프로그램을 대상으로 하는 시험 기법, 입력 값과 상태를 고려하여 시험 데이터 생성
근원 상태의 입력값에 대해서 잘못된 결과값을 출력하는 출력 오류와 전이오류를 확인 하는것
상태 전이 테스팅이 대표적인 기법

상태 전이 테스팅
소프트웨어 또는 시스템을 상태 사이의 관계 즉, 상태 간의 전이, 상태를 변화시키는 이벤트와 입력 값, 상태의 변화로 유발되는 동작 등을 파악
시스템은 현재상황이나 이전의 이력을 반영하는 상태 및 변화에 따라 다르게 동작
시스템의 이러한 측면을 상태전이 다이어그램으로 표현
테스트 대상 시스템이나 객체의 상태는 개별적으로 식별 가능하고 유한한 개수로 표현
상태 전이 다이어그램을 테이블 형태로 전환한 상태 테이블은 상태와 입력 값 간의 관계를 보여주고 개연성은 있지만 요구사항과 맞지않는 전이를 보여줄 수도 있음
상태 다이어그램으로 시스템을 설계하는 경우, 존재하는 결함을 아래와 같이 모델상의 결함과 구현상의 결함으로 분류
상태 다이어 그램에서 모델상의 결함은 인스펙션 및 리뷰 기법과 정적 분석 툴로 발견하는 것이 가능하며, 구현상의 결함은 테스팅을 통해 발견 가능
상태 전이 테스팅은 일반적으로 임베디드 소프트웨어 산업분야나 기술적으로 자동화가 필요한 부분에서 사용
특정한 상태를 갖는 비즈니스 객체 모델링이나 인터넷 어플리케이션 또는 비즈니스 시나리오와 같이 화면-대화 창 흐름을 테스팅 할 때도 유용하게 적용 가능
 상태 전이 테스팅의 설계 절차 (상태 전이 다이어그램 존재 시)
- 상태-이벤트 테이블 구성
- 전이 트리 구성
- 반응(Legal, 또는 유효(Valid)테스트 케이스 구성
- 무반응(Illegal, 또는 비유효(Invalid)테스트 케이스 구성
- 가드(Guard) 또는 조건 테스트 케이스 구성
- 테스트 프로시저(Test Procedure) 구성

유즈케이스 테스팅
유스케이스나 비즈니스 시나리오를 기반으로 테스트를 명세화 하는 방법
주류 시나리오 또는 기본 흐름과 대체 흐름으러 구성

페어와이즈 조합 테스팅
커버해야 할 기능적 범위에 비해 상대적으로 적은 양의 테스트 세트를 구성하여 소프트웨어의 결함을 찾고 테스트에 대한 자신감을 얻을 수 있는 방법
대부분의 결함이 2개 요소의 상호작용에 기인한다는 것에 착안, 2개 요소의 모든 조합을 다룸
자원, 시간적으로 제한된 상황에서 테스트 대상 소프트웨어의 설정, 기능 등의 조합을 모두 테스트 하는 것은 현실적/경제적으로 가능하지 않은 경우가 대부분
반면, 테스트를 하지 않거나 일부 조합을 의도적으로 누락시키는 것은 그만큼의 리스크를 동반하게 되므로 조합 테스팅은 매주 중요한 의미를 가짐
경험적으로 읨 ㅣ있고 결함을 발견할 가능성이 높다고 판단되는 조합을 추가하여 관리 가능한 선에서 조합을 늘리는 것은 조합테스팅의 효율을 높이는데 도움이 됨

8장
화이트 박스 테스트 : 구현된 코드를 테스트 설계의 기반으로 사용하는 테스트 기법(코드 기반) 

화이트박스와 블랙박스 테스트는 상호 보완적
명세서 상의 오류, 구현 상의 누락, 실수와 같은 것은 블랙박스 테스트로 확인 가능
화이트박스 테스트는 프로그램의 제어, 자료 구조 등을 테스트 설계에 활용

화이트박스 테스트
모듈 내부를 테스트하는 방법(단위 테스트에 적합)

제어흐름과 테스팅
프로그램의 구조를 테스트 설계에 활용하기 위해서는 프로그램의 제어 구조를 정확히 파악

결정테스팅
- 조건 식에 집중
각 조건식의 참과 거짓이 되는 경우가 최소 한번씩은 테스트케이스에 포함되는 입력을 제공해야 함

조건테스트
주어진 복합조건식 내의 모든 단순 조건의 참, 거짓의 경우를 최소한 한번씩 테스트 하도록 설계
대부분의 경우 결정 테스트보다 더 철저한 테스트 가능
보완 : 조건 결정, 개선된 결정, 다중 조건
개별 조건식이 모두 T/F -> 전체조건식이 무조건 T/F는 아님

9장
경로테스트
프로그램 내의 모든 경로에 대해 정확성을 알 수 있으면 프로그램이 명세서와 일치함을 증명할 수 있음
SW의 크기 증가에 따른 경로 수 증가 등으로 완벽한 경로 테스트는 어려움

루프테스트
코드 내에 조건부 반복 구조가 존재할 경우 테스트해야 할 경로의 수는 확정하기 어려움

중첩된 루프테스트
바깥 루프의 반복 회수를 최소값 설정 가장 안쪽의 루프를 테스트
연속된 루프테스트
상호 독립적 -> 일반적인 루프 테스트 적용
상호 독립적 x -> 중첩된 루프테스트 적용

데이터 흐름 테스트
실행 중 프로그램 내의 데이터 요소에 일어나는 일에 집중하여 조사하는 테스트 방법
데이터 처리와 관련된 결함을 발견하는데 도움
정의-사용 관계상의 문제점을 확인할 수 있는 실행 경로를 찾아 결함 발견

탐침 삽입
전략적 지점에 탐침을 삽입하여 결함을 발견하느 ㄴ방법
탐침 : 프로그램에 추가되는 문장의 형태
프로그램의 정확성 증명에 자주 활용

회귀 테스트
SW에 수정이 잘 이루어졌는지 다른 부분에 영향이 없는지 확인하는 테스트
소프트웨어에 변경이 가해질 때에는 반드시 따르는 중요 테스트
기존 테스트 케이스의 재사용 및 일부 변경 + 새로운 테스트 케이스 추가
살충제 패러독스를 유도
슬라이싱, 데이터 흐름, 클러스터, 

경험 기반 기법
테스터의 능력을 기반으로 테스트 케이스 추출

탐색적 테스팅
휴리스틱한 테스팅 접근법
테스트 케이스 기반 vs 탐색적
탐색적 -> 문서를 최소화, 점진적
테스트 케이스 -> 완벽하게 한번에 테스팅을 수행

객체 지향 소프트웨어 테스트 개요
특성
- 데이터 추상화
- 정보 은닉
- 상속
- 재사용성
장점 - 융통성, 생산성
문제점 - 비절차적, 구조화 미비, 다양성, 복잡성
구조상의 에러는 정적 분석으로 검출 가능

클래스 테스팅
하나의 클래스는 다수의 멤버 데이터와 메소드로 구성
슬라이싱 기법 : 시퀀스를 테스팅
MM Path 기법 : 경로는 메시지로 연결된 메소드들의 수행 시퀀스 
상태기반 테스트 기법 : 특정 시점에서의 객체의 상태의 변화를 테스팅하는 방법

클래스 상속 관계 테스팅

컴포넌트 테스팅
컴포넌트 기반 소프트웨어 개발(CBSD)는 확보된 컴포넌트의 품질이 중요

